from __future__ import annotations

import torch
from dataclasses import MISSING
from typing import TYPE_CHECKING

from omni.isaac.lab.assets import Articulation
from omni.isaac.lab.managers import ActionTerm, ActionTermCfg
from omni.isaac.lab.utils import configclass

if TYPE_CHECKING:
    from omni.isaac.lab.envs import ManagerBasedRLEnv


class BodyTorqueControlAction(ActionTerm):
    r"""Body torque control action term.

    This action term applies body torques and combined thrust to the drone body frame.
    The raw actions correspond to the 3 torques and total thrust generated by the motors.

    """

    cfg: BodyTorqueControlActionCfg
    """The configuration of the action term."""

    def __init__(self, cfg: BodyTorqueControlActionCfg, env: ManagerBasedRLEnv) -> None:
        # initialize the action term
        super().__init__(cfg, env)

        self._robot: Articulation = env.scene[cfg.asset_name]
        self._body_id = self._robot.find_bodies("body")[0]

        self._raw_actions = torch.zeros(self.num_envs, self.action_dim, device=self.device)

    """
    Properties.
    """

    @property
    def action_dim(self) -> int:
        return 4

    @property
    def raw_actions(self) -> torch.Tensor:
        return self._raw_actions

    @property
    def processed_actions(self) -> torch.Tensor:
        return self.raw_actions
    
    @property
    def has_debug_vis_implementation(self) -> bool:
        return False

    """
    Operations.
    """

    def process_actions(self, actions: torch.Tensor):
        self._raw_actions[:] = actions

    def apply_actions(self):
        forces = torch.zeros(self.num_envs, 1, 3, device=self.device)
        torques = torch.zeros_like(forces)
        
        torques[:, 0, :] = self._raw_actions[:, :3]
        forces[:, 0, 2] = self._raw_actions[:, 3]

        self._robot.set_external_force_and_torque(forces, torques, body_ids=self._body_id)
        self._robot.update(self._env.physics_dt)
        self._robot.write_data_to_sim()

    def reset(self, env_ids):
        joint_pos, joint_vel = self._robot.data.default_joint_pos, self._robot.data.default_joint_vel
        self._robot.write_joint_state_to_sim(joint_pos, joint_vel)
        # self._robot.write_root_pose_to_sim(self._robot.data.default_root_state[:, :7])
        self._robot.write_root_velocity_to_sim(self._robot.data.default_root_state[:, 7:])
        self._robot.reset()


@configclass
class BodyTorqueControlActionCfg(ActionTermCfg):
    """
    See :class:`BodyTorqueControlAction` for more details.
    """

    class_type: type[ActionTerm] = BodyTorqueControlAction
    """ Class of the action term."""
    asset_name: str = MISSING
    """Name of the asset in the environment for which the commands are generated."""
